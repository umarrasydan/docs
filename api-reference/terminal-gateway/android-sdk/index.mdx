---
title: "Android SDK (Kotlin)"
description: "Integrate Xendit's Payment Terminal Gateway into your Android applications with our comprehensive Kotlin SDK"
---

# Terminal Gateway SDK for Android (Kotlin)

The Xendit's Payment Terminal Gateway Android SDK enables you to integrate secure payment processing into your Android applications. Connect to physical payment terminals and process transactions seamlessly using our Kotlin-based SDK.

<Info>
This SDK works alongside the Terminal API to provide complete in-person payment functionality. You'll use the Terminal API to create payment sessions and this SDK to interact with physical payment devices.
</Info>

## Version information

<AccordionGroup>
  <Accordion title="v0.4.1 — 7-Oct-2025">
    Bug fixes and improvements:
    - Fix data mapping for terminal responses
  </Accordion>

  <Accordion title="v0.4.0 — 13-May-2025">
    XenTerminal is the companion SDK to In-Person Payment Sessions API. This version provides core functionality for connecting to payment terminals and processing transactions.
  </Accordion>
</AccordionGroup>

<Note>
The SDK follows semantic versioning. Breaking changes will bump the major version number.
</Note>

## Download

Download the Terminal Gateway Android SDK:

<CardGroup cols={1}>
<Card title="Android SDK (v0.4.1)" icon="android" href="https://xnd-secops.s3.ap-southeast-1.amazonaws.com/inpersonpayments/TerminalGateway+Android-0.4.1.zip">
  Download the complete Android SDK package including all dependencies and documentation

  ```
  SHA256: 534adb1af2f01ed7741560d0d9f1387f9a2760b1491a610a680b34477e54073f
  ```
</Card>
</CardGroup>

## Installation

Follow these steps to add the Terminal Gateway Android SDK to your project.

<Steps>
<Step title="Extract the SDK">
  Extract the provided SDK zip file so that a `repository` directory is available in your project root.
  
  <Check>
  Verify that the `repository` folder contains the necessary Maven artifacts for the SDK.
  </Check>
</Step>

<Step title="Configure Gradle settings">
  Add the repository to your Gradle configuration. Choose one of the following approaches:
  
  <Tabs>
  <Tab title="Modern Approach (Recommended)">
    Add the repository to your Gradle settings file:
    
    <CodeGroup>
    ```kotlin settings.gradle(.kts)
    dependencyResolutionManagement {
      repositories {
        // ... other repositories
        maven("./repository")
      }
    }
    ```
    
    ```groovy settings.gradle
    dependencyResolutionManagement {
      repositories {
        // ... other repositories
        maven { url './repository' }
      }
    }
    ```
    </CodeGroup>
  </Tab>
  
  <Tab title="Old Android Project">
    Add the repository to your root build.gradle file:
    
    <CodeGroup>
    ```kotlin build.gradle.kts (root)
    allprojects {
      repositories {
        // ... other repositories
        maven("../repository")
      }
    }
    ```
    
    ```groovy build.gradle (root)
    allprojects {
      repositories {
        // ... other repositories
        maven { url '../repository' }
      }
    }
    ```
    </CodeGroup>
  </Tab>
  </Tabs>
</Step>

<Step title="Add dependencies">
  Add the required dependencies to your app module's `build.gradle` file:
  
  <CodeGroup>
  ```kotlin build.gradle.kts
  dependencies {
    implementation("co.xendit.terminal:core-android:<latest_version>")
    implementation("co.xendit.terminal:gateway-android:<latest_version>")
    implementation("co.xendit.terminal:id-bri-android:<latest_version>")

    // GHL (Thailand) - uncomment if needed
    // implementation("co.xendit.terminal:th-ghl-android:<latest_version>")
  }
  ```
  
  ```groovy build.gradle
  dependencies {
    implementation 'co.xendit.terminal:core-android:<latest_version>'
    implementation 'co.xendit.terminal:gateway-android:<latest_version>'
    implementation 'co.xendit.terminal:id-bri-android:<latest_version>'

    // GHL (Thailand) - uncomment if needed
    // implementation 'co.xendit.terminal:th-ghl-android:<latest_version>'
  }
  ```
  </CodeGroup>
  
  <Warning>
  Only add the terminal provider dependencies you actually need. Each provider adds to your app's size.
  </Warning>
</Step>
</Steps>

## Getting Started

Before you begin, ensure you have the following:

- **Client key**: Request an In-Person Payment `CLIENT_KEY` from the Xendit team
- **Terminal device information**: Obtain the Terminal ID and IP address for each device
- **Android project**: Set up with minimum SDK version 21 (Android 5.0)

<Warning>
Keep your client key secure and never commit it to version control. Use environment variables or secure storage for production applications.
</Warning>

### Step 1: Initialize the SDK

Initialize the Terminal Gateway SDK in your Application class:

```kotlin MyApp.kt
class MyApp : Application() {
  override fun onCreate() {
    super.onCreate()

    TerminalApp.initialize(
      application = this,
      clientKey = TEST_CLIENT_KEY,
      mode = TerminalMode.INTEGRATION
    )

    // Add terminal providers based on your needs
    TerminalGateway.addProvider(TerminalBRI)
    // TerminalGateway.addProvider(TerminalGHL)
  }
}
```

<Note>
Use `TerminalMode.INTEGRATION` for development and testing. Switch to `TerminalMode.LIVE` for production with a live client key.
</Note>

### Step 2: Register Terminal Devices

Register your terminal devices with the SDK:

```kotlin
TerminalGateway.registerDevice(
  listOf(
    TerminalDevice(TERMINAL_ID_1, TERMINAL_IP_1),
    TerminalDevice(TERMINAL_ID_2, TERMINAL_IP_2)
  )
)

// Registration completed - devices are now available for use
Log.i("TerminalGateway", "Devices registered successfully")
```

<Check>
After successful registration, your terminal devices will be available for payment processing.
</Check>

## Configuration and Management

### Set Operation Timeout

Configure the timeout for terminal operations:

```kotlin
// Set timeout to 5 minutes (default)
TerminalGateway.setOperationTimeout(minutes = 5)

// Set custom timeout for longer operations
TerminalGateway.setOperationTimeout(minutes = 10)
```

<Note>
The default timeout is 5 minutes. Increase this value if you expect longer processing times for complex transactions.
</Note>

<Warning>
This timeout configuration is only available for the BRI provider. Other terminal providers use their own internal timeout settings.
</Warning>

### Restart Terminal Connection

Manage and restart terminal service connections:

<Tabs>
<Tab title="Restart All Connections">
  Call the method without parameters to restart all connections and tasks:
  
  ```kotlin
  // This restarts all connections
  TerminalGateway.restart()
  ```
</Tab>

<Tab title="Restart Single Connection">
  Provide the terminal ID to restart a specific terminal connection:
  
  ```kotlin
  // This restarts the connection to a specific Terminal
  TerminalGateway.restart(terminalID = TERMINAL_ID)
  ```
</Tab>
</Tabs>

### Monitor Connection State

Observe terminal connection states in real-time:

<Tabs>
<Tab title="Using Coroutine Scope">
  Use the `observeConnection` method with a coroutine scope:
  
  ```kotlin
  TerminalGateway.observeConnection(
    CoroutineScope(Dispatchers.IO),
    terminalDevice
  ) { state ->
    when (state) {
      ConnectionState.CONNECTED -> {
        // Terminal is ready for transactions
        Log.i("Terminal", "Connected to ${terminalDevice.id}")
      }
      ConnectionState.DISCONNECTED -> {
        // Terminal is offline
        Log.w("Terminal", "Disconnected from ${terminalDevice.id}")
      }
      ConnectionState.CONNECTING_FAILED -> {
        // Connection attempt failed
        Log.e("Terminal", "Failed to connect to ${terminalDevice.id}")
      }
      // ... handle other states
    }
  }
  ```
</Tab>

<Tab title="Using Flow">
  Use the connection state Flow directly:
  
  ```kotlin
  val connectionStateFlow = terminalDevice.connectionState
  connectionStateFlow.collect { state ->
    // Handle connection state changes
    when (state) {
      ConnectionState.CONNECTED -> {
        // Terminal is ready for transactions
        Log.i("Terminal", "Connected to ${terminalDevice.id}")
      }
      ConnectionState.DISCONNECTED -> {
        // Terminal is offline
        Log.w("Terminal", "Disconnected from ${terminalDevice.id}")
      }
      // ... handle other states
    }
  }
  ```
</Tab>
</Tabs>

### Connection States

| State | Description |
|-------|-------------|
| CONNECTED | Device successfully connected to terminal and ready for transactions |
| DISCONNECTED | Device disconnected from terminal or network unavailable |
| UNKNOWN | Initial state before any connection attempt |
| CONNECTING | Currently establishing connection to terminal |
| CONNECTING_FAILED | Connection attempt failed due to network or authentication issues |
| UNSUPPORTED | Terminal type or connection method not supported |

### Monitor Error States

Observe and handle errors across all terminal devices:

```kotlin
// Global error monitoring
TerminalGateway.observeError(
  CoroutineScope(Dispatchers.IO)
) { device, error ->
  Log.e("TerminalGateway", "Error on ${device.id}: ${error.message}")
  
  when (error.code) {
    ErrorCode.TERMINAL_BUSY -> {
      // Terminal is processing another transaction
      // Wait and retry later
    }
    ErrorCode.FAILED_TO_CONNECT -> {
      // Network connectivity issue
      // Check network connection and terminal IP
    }
    ErrorCode.AUTHENTICATION_FAILED -> {
      // Invalid credentials or terminal ID
      // Verify client key and terminal configuration
    }
    // ... handle other error codes
  }
}

// Device-specific error monitoring
val errorFlow = TerminalGateway.errorState(terminalDevice)
val deviceErrorFlow = terminalDevice.error
```

## Error Handling

### Error Data Structure

All errors returned by the Terminal Gateway SDK follow this structure:

```kotlin
data class TerminalError(
  val code: ErrorCode,
  val message: String
)
```

### Error Codes Reference

| Error Code | HTTP Status | Description |
|------------|-------------|-------------|
| INVALID_CREDENTIAL | 401 | Provided credentials are invalid or expired |
| INVALID_REQUEST | 400 | Request format or parameters are invalid |
| INTERNAL_SERVER_ERROR | 500 | Server-side error occurred during processing |
| UNKNOWN_ERROR | 0 | Unexpected error that doesn't fit other categories |
| KEY_INVALID | -1 | API key is invalid or not authorized |
| SEND_FAILED | -2 | Failed to send data to the terminal device |
| NOT_CONNECTED | -3 | No active connection to any terminal device |
| FAILED_TO_CONNECT | -4 | Unable to establish connection to terminal |
| UNSUPPORTED | -5 | Operation or platform not supported |
| TERMINAL_BUSY | -6 | Terminal is processing another transaction |
| ENCRYPTION_FAILED | -7 | Encryption key invalid or encryption process failed |
| AUTHENTICATION_FAILED | -21 | Terminal authentication failed - check TID and credentials |

### Error Handling Best Practices

Implement comprehensive error handling for robust payment processing:

```kotlin
fun handleTerminalError(error: TerminalError?) {
  when (error?.code) {
    ErrorCode.AUTHENTICATION_FAILED -> {
      // Verify API key and terminal ID
      Log.e("TerminalGateway", "Authentication failed: ${error.message}")
      // Show user-friendly message and retry with correct credentials
    }
    
    ErrorCode.TERMINAL_BUSY -> {
      // Terminal is processing another transaction
      Log.w("TerminalGateway", "Terminal busy: ${error.message}")
      // Wait and retry after a delay
      retryAfterDelay(5000) // 5 seconds
    }
    
    ErrorCode.FAILED_TO_CONNECT, ErrorCode.NOT_CONNECTED -> {
      // Network connectivity issues
      Log.e("TerminalGateway", "Connection failed: ${error.message}")
      // Check network connection and terminal IP address
      checkNetworkConnectivity()
    }
    
    ErrorCode.KEY_INVALID, ErrorCode.INVALID_CREDENTIAL -> {
      // Credential issues
      Log.e("TerminalGateway", "Invalid credentials: ${error.message}")
      // Rotate or refresh API credentials
      refreshCredentials()
    }
    
    ErrorCode.ENCRYPTION_FAILED -> {
      // Encryption key issues
      Log.e("TerminalGateway", "Encryption failed: ${error.message}")
      // Re-initialize SDK with correct encryption keys
      reinitializeSDK()
    }
    
    else -> {
      // Log and escalate unknown errors
      Log.e("TerminalGateway", "Unknown error: ${error?.message}")
      // Report to monitoring system
      reportError(error)
    }
  }
}
```

<Tip>
Always implement retry logic for transient errors like `TERMINAL_BUSY` and `FAILED_TO_CONNECT`. Use exponential backoff to avoid overwhelming the terminal.
</Tip>

## Troubleshooting

### Common Issues and Solutions

<AccordionGroup>
<Accordion title="Unresponsive EDC Machine">
  **Problem**: The EDC (Electronic Data Capture) machine becomes unresponsive or stops processing transactions.

  **Solution**: 
  1. Restart the EDC machine by holding the power button and selecting "Restart"
  2. Wait for the device to fully boot up and reconnect
  3. Verify the terminal is back online using the connection monitoring features

  <Warning>
  Always ensure the EDC is properly restarted before attempting new transactions to avoid data corruption.
  </Warning>
</Accordion>

<Accordion title="Kiosk Mode Configuration">
  **Problem**: Unexpected behaviors or unauthorized access to terminal functions.

  **Solution**:
  1. Ensure all transactions are initiated only through the SDK
  2. Contact the Xendit EDC team to enable POS-only mode for your Terminal IDs
  3. Configure terminal settings to disable manual transaction entry

  <Tip>
  POS-only mode prevents manual transaction entry and ensures all operations go through your application.
  </Tip>
</Accordion>

<Accordion title="No Response After Payment Completion">
  **Problem**: EDC fails to send transaction results to the SDK after payment completion.

  **Solution**:
  1. Query the Payment Session using the Terminal API to retrieve the latest status
  2. Check network connectivity between the EDC and your application
  3. Verify the callback URL configuration in your payment session
  4. Implement retry logic for failed status updates

  ```kotlin
  // Example: Query payment session status
  val paymentSession = terminalApi.getPaymentSession(sessionId)
  when (paymentSession.status) {
    PaymentStatus.COMPLETED -> {
      // Process successful payment
    }
    PaymentStatus.FAILED -> {
      // Handle failed payment
    }
    PaymentStatus.PENDING -> {
      // Payment still in progress
    }
  }
  ```
</Accordion>

<Accordion title="Connection Issues">
  **Problem**: Unable to establish or maintain connection with terminal devices.

  **Solutions**:
  - **Check network connectivity**: Ensure both devices are on the same network
  - **Verify IP addresses**: Confirm terminal IP addresses are correct and accessible
  - **Firewall settings**: Check if firewall is blocking the connection ports
  - **Terminal status**: Ensure the terminal is powered on and in ready state
  - **SDK initialization**: Verify client key and terminal configuration

  <Note>
  Use the connection monitoring features to diagnose specific connection issues.
  </Note>
</Accordion>
</AccordionGroup>

import FindingTerminalInformation from '/snippets/finding-terminal-information.mdx';

<FindingTerminalInformation />
